#!/usr/bin/env python3
import os, sys, json
try:
    import yaml
except ImportError:
    print("PyYAML not installed. Install with: pip install pyyaml", file=sys.stderr)
    sys.exit(1)

HEADER = """
// Auto-generated by tools/dialogue_yaml_to_c.py
// Do not edit by hand.
#ifndef AME_DIALOGUE_GENERATED_H
#define AME_DIALOGUE_GENERATED_H
#include <stddef.h>
#include "ame_dialogue.h"
#define AME_HAVE_GENERATED_DIALOGUES 1
extern const AmeDialogueScene *ame__generated_scenes[];
extern const size_t ame__generated_scenes_count;
#endif
""".strip() + "\n"

C_SOURCE_PREAMBLE = """
// Auto-generated by tools/dialogue_yaml_to_c.py
// Do not edit by hand.
#include "ame_dialogue.h"
#include <stddef.h>

""".strip() + "\n"


def sanitize_c_ident(s: str) -> str:
    out = []
    for ch in s:
        if ch.isalnum() or ch == '_':
            out.append(ch)
        else:
            out.append('_')
    ident = ''.join(out)
    if ident and ident[0].isdigit():
        ident = '_' + ident
    return ident


def emit_scene(name: str, scene: dict, out_lines: list):
    base = sanitize_c_ident(name)
    option_arrays = []
    # Pre-emit options arrays
    lines = scene.get('lines', []) or []
    for i, line in enumerate(lines):
        opts = line.get('options') or []
        if opts:
            arr_name = f"{base}_opts_{i}"
            option_arrays.append((arr_name, opts))
    for arr_name, opts in option_arrays:
        out_lines.append(f"static const AmeDialogueOption {arr_name}[] = {{")
        for opt in opts:
            choice = (opt.get('choice') or '').replace('"', '\\"')
            nxt = (opt.get('next') or '').replace('"', '\\"')
            out_lines.append(f"    {{\"{choice}\", \"{nxt}\"}},")
        out_lines.append("};\n")

    # Emit lines array
    lines_var = f"{base}_lines"
    out_lines.append(f"static const AmeDialogueLine {lines_var}[] = {{")
    for i, line in enumerate(lines):
        def f(key):
            val = line.get(key)
            if val is None:
                return 'NULL'
            s = str(val).replace('"', '\\"')
            return f'"{s}"' if s else 'NULL'
        opts = line.get('options') or []
        if opts:
            arr_name = f"{base}_opts_{i}"
            opt_ptr = arr_name
            opt_cnt = str(len(opts))
        else:
            opt_ptr = 'NULL'
            opt_cnt = '0'
        out_lines.append(
            "    { %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s }," % (
                f('id'), f('speaker'), f('text'), f('sprite'), f('sound'), f('animation'),
                f('cutscene'), f('trigger'), f('quest_id'), f('next_scene'), opt_ptr, opt_cnt
            )
        )
    out_lines.append("};\n")

    # Emit scene object
    scene_var = f"scene_{base}"
    scene_name_c = name.replace('"', '\\"')
    out_lines.append(f"static const AmeDialogueScene {scene_var} = {{ .scene=\"{scene_name_c}\", .lines={lines_var}, .line_count=sizeof({lines_var})/sizeof({lines_var}[0]) }};\n")

    return scene_var


def emit_route(name: str, route: dict, out_lines: list):
    base = sanitize_c_ident(name)
    edge_arrays = []
    nodes = route.get('nodes') or []
    for i, node in enumerate(nodes):
        edges = node.get('edges') or []
        if edges:
            arr_name = f"{base}_edges_{i}"
            edge_arrays.append((arr_name, edges))
    for arr_name, edges in edge_arrays:
        out_lines.append(f"static const AmeStoryEdge {arr_name}[] = {{")
        for e in edges:
            choice = (e.get('choice') or '').replace('"', '\\"')
            to = (e.get('to') or '').replace('"', '\\"')
            out_lines.append(f"    {{ \"{choice}\", \"{to}\" }},")
        out_lines.append("};\n")
    # Emit nodes array
    nodes_var = f"{base}_nodes"
    out_lines.append(f"static const AmeStoryNode {nodes_var}[] = {{")
    for i, node in enumerate(nodes):
        nid = (node.get('id') or '').replace('"', '\\"')
        scene = (node.get('scene') or '').replace('"', '\\"')
        entry = (node.get('entry') or '')
        if not entry:
            entry_c = 'NULL'
        else:
            entry_c = f'"{entry.replace("\"","\\\"")}"'
        edges = node.get('edges') or []
        if edges:
            arr_name = f"{base}_edges_{i}"
            edge_ptr = arr_name
            edge_cnt = str(len(edges))
        else:
            edge_ptr = 'NULL'
            edge_cnt = '0'
        out_lines.append(f"    {{ \"{nid}\", \"{scene}\", {entry_c}, {edge_ptr}, {edge_cnt} }},")
    out_lines.append("};\n")
    # Emit route object
    route_var = f"route_{base}"
    route_name_c = name.replace('"', '\\"')
    out_lines.append(f"static const AmeStoryRoute {route_var} = {{ .name=\"{route_name_c}\", .nodes={nodes_var}, .node_count=sizeof({nodes_var})/sizeof({nodes_var}[0]) }};\n")
    return route_var


def main():
    if len(sys.argv) < 3:
        print("Usage: tools/dialogue_yaml_to_c.py <input_dir> <output_dir>", file=sys.stderr)
        sys.exit(2)
    in_dir = sys.argv[1]
    out_dir = sys.argv[2]
    if not os.path.isdir(in_dir):
        print(f"Input dir not found: {in_dir}", file=sys.stderr)
        sys.exit(3)
    os.makedirs(out_dir, exist_ok=True)
    # Collect YAML files
    yamls = []
    for root, dirs, files in os.walk(in_dir):
        for f in files:
            if f.lower().endswith(('.yaml', '.yml')):
                yamls.append(os.path.join(root, f))
    if not yamls:
        print("No YAML files found.", file=sys.stderr)
    # Generate header and c source
    header_path = os.path.join(out_dir, 'dialogue_generated.h')
    src_path = os.path.join(out_dir, 'embedded_dialogues_gen.c')

    with open(header_path, 'w') as hf:
        hf.write(HEADER)

    lines = [C_SOURCE_PREAMBLE]
    scene_ptrs = []
    route_ptrs = []

    # Support simple include mechanism: if a YAML has an 'includes' key with list of filenames,
    # load them first and merge scenes into output. Relative paths resolved against in_dir.
    def resolve_includes(basefile, data):
        incs = data.get('includes') or []
        for inc in incs:
            inc_path = inc
            if not os.path.isabs(inc_path):
                inc_path = os.path.join(os.path.dirname(basefile), inc_path)
            if os.path.isdir(inc_path):
                for root, dirs, files in os.walk(inc_path):
                    for f in files:
                        if f.lower().endswith(('.yaml', '.yml')):
                            with open(os.path.join(root, f), 'r', encoding='utf-8') as f2:
                                d = yaml.safe_load(f2) or {}
                            yield os.path.join(root, f), d
            elif os.path.isfile(inc_path):
                with open(inc_path, 'r', encoding='utf-8') as f2:
                    d = yaml.safe_load(f2) or {}
                yield inc_path, d

    for yf in yamls:
        with open(yf, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f) or {}
        # First process includes
        for inc_file, inc_data in resolve_includes(yf, data):
            # emit any scenes contained in included files
            if 'lines' in inc_data or 'scene' in inc_data:
                name = inc_data.get('scene') or os.path.splitext(os.path.basename(inc_file))[0]
                scene_ptrs.append(emit_scene(name, inc_data, lines))
            elif isinstance(inc_data, dict):
                for name, scene in inc_data.items():
                    if isinstance(scene, dict) and ('lines' in scene or 'scene' in scene):
                        scene_ptrs.append(emit_scene(name, scene, lines))

        # Accept either a single scene, a route, or a mapping
        if 'route' in data and 'nodes' in data:
            name = data.get('route') or os.path.splitext(os.path.basename(yf))[0]
            route_ptrs.append(emit_route(name, data, lines))
        elif 'title' in data or 'scene' in data or 'lines' in data:
            name = data.get('scene') or os.path.splitext(os.path.basename(yf))[0]
            scene_ptrs.append(emit_scene(name, data, lines))
        elif isinstance(data, dict):
            for name, scene in data.items():
                if isinstance(scene, dict) and ('lines' in scene or 'scene' in scene):
                    scene_ptrs.append(emit_scene(name, scene, lines))
                elif isinstance(scene, dict) and ('route' in scene or 'nodes' in scene):
                    nm = scene.get('route') or name
                    route_ptrs.append(emit_route(nm, scene, lines))

    # Registries
    lines.append("const AmeDialogueScene *ame__generated_scenes[] = {")
    for sv in scene_ptrs:
        lines.append(f"    &{sv},")
    lines.append("};\n")
    lines.append(f"const size_t ame__generated_scenes_count = sizeof(ame__generated_scenes)/sizeof(ame__generated_scenes[0]);\n")


    with open(src_path, 'w') as sf:
        sf.write('\n'.join(lines))

    print(f"Wrote {header_path}\nWrote {src_path}")

if __name__ == '__main__':
    main()
